=> It provides the basic implementation of the Map interface in Java. HashMap stores data
   in (key, value) pairs. Each key is associated with a value, and you can access the value
   by using the corresponding key.

=> It Internally uses Hashing (similar to Hashtable in Java).
=> Not synchronized (unlike Hashtable in Java) and hence faster for most of the cases.
=> Allows to store the null keys as well, but there should be only one null key object, and
   there can be any number of null values.
=> Duplicate keys are not allowed in HashMap, if you try to insert the duplicate key, it will
   replace the existing value of the corresponding key.
=> HashMap uses keys in the same way as an Array uses an index.
=> HashMap allows for efficient key-based retrieval, insertion, and removal with an average O(1)
   time complexity.


Characteristics of HashMap
A HashMap is a data structure that is used to store and retrieve values based on keys. Some of
the key characteristics of a hashmap include:

= Not ordered: HashMaps are not ordered, which means that the order in which elements are added
  to the map is not preserved. However, LinkedHashMap is a variation of HashMap that preserves
  the insertion order.
= Thread-unsafe: HashMaps are not thread-safe, which means that if multiple threads access the
  same hashmap simultaneously, it can lead to data inconsistencies. If thread safety is required,
  ConcurrentHashMap can be used.
= Capacity and load factor: HashMaps have a capacity, which is the number of elements that it can
  hold, and a load factor, which is the measure of how full the hashmap can be before it is resized.

=========>>>>>>>> DSA Problems On HashMap
1. Count Frequencies in an Array
2. Most Frequent Element
3. Count distinct elements in every window of size K
4. Check if two arrays are equal or not
5. 2 Sum - Count Pairs with target sum
6. Count all pairs with absolute difference equal to K
7. Check If Array Pair Sums Divisible by K
8. Max distance between two occurrences in array
9. Subarray with Given Sum â€“ Handles Negative Numbers
10. Remove minimum elements such that no common elements exist in two arrays
11. 3 Sum - Count all triplets with target sum
12. Longest Subarray with Sum Divisible by K
13. Longest Subarray having Majority Elements Greater than K